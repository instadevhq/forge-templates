package main

import (
    "fmt"
    "log"
    "net/http"
    "database/sql"
    "errors"
    "encoding/json"
    "time"
    "runtime"
    "os"

    "github.com/lib/pq"
    chi "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/georgysavva/scany/v2/sqlscan"
    _ "github.com/lib/pq"
    minio "github.com/minio/minio-go"
    "github.com/google/uuid"

    {{!-- {{#each app.types}}
    {{#each this.fields}}
    "{{goTypeImports typeName}}"
    {{/each}}
    {{/each}} --}}
)

{{#each app.types as | typedef | }}
{{> typedef}}
{{#if (eq typedef.typeOf 1)}}

func (t {{camel typedef.name}}) Error() string {
    return fmt.Sprintf("{{camel typedef.name}}: [{{#each typedef.fields}}{{lowerCamel this.name}} = (%v){{#if @last}}{{else}}, {{/if}}{{/each}}]", {{#each typedef.fields}}t.{{camel this.name}}{{#if @last}}{{else}}, {{/if}}{{/each}})
}

func (t {{camel typedef.name}}) MustJSONError() string {
    dat, err := json.MarshalIndent(map[string]any{
        "error": map[string]any{
            "_typeof": "{{camel typedef.name}}",
{{#each typedef.fields}}
            "{{lowerCamel this.name}}": t.{{camel this.name}},
{{/each}}
        },
    }, "", "    ")
    if err != nil {
        panic(fmt.Errorf("failed to generate {{camel typedef.name}} JSON error: %w", err))
    }

    return string(dat)
}

{{#if typedef.formFields}}
func MustNew{{camel typedef.name}}({{#if typedef.formPlan.databaseOperations}}conn *sql.DB, {{/if}}{{#each typedef.formFields}}{{name}} {{{goType typeName}}}{{#if @last}}{{else}}, {{/if}}{{/each}}) {{camel typedef.name}} {
    val, err := New{{camel typedef.name}}({{#if typedef.formPlan.databaseOperations}}conn, {{/if}}{{#each typedef.formFields}}{{name}}{{#if @last}}{{else}}, {{/if}}{{/each}})
    if err != nil {
        panic(fmt.Errorf("failed to form {{camel typedef.name}} type: %w", err))
    }

    return val
}

func New{{camel typedef.name}}({{#if typedef.formPlan.databaseOperations}}conn *sql.DB, {{/if}}{{#each typedef.formFields}}{{name}} {{{goType typeName}}}{{#if @last}}{{else}}, {{/if}}{{/each}}) ({{camel typedef.name}}, error) {
    result := {{camel typedef.Name}}{}
    
    {{#each typedef.formPlan.databaseOperations}}
    {{!-- {{this.mustGetSQLArgs}} --}}
    const sqlStr = `{{{this.mustToSQL}}}`
    rows, err := conn.Query(sqlStr, {{#each typedef.formFields}}{{name}}{{#if @last}}{{else}}, {{/if}}{{/each}})
    if err != nil {
        return {{camel this.name}}{}, fmt.Errorf("failed to execute sql query for method 'New{{camel this.Name}}': %w", err)
    }

    rowVal := []map[string]interface{}{}
    err = sqlscan.ScanAll(&rowVal, rows)
    if err != nil {
        return {{camel this.name}}{}, fmt.Errorf("failed to scan sql query results for method 'New{{camel this.Name}}': %w", err)
    }

    if len(rowVal) == 0 {
        return {{camel this.name}}{}, errors.New("no results returned by query from 'New{{camel this.Name}}'")
    }
    row := rowVal[0]

{{#each this.dataFieldMappings}}
{{#with (lookupField app @key) as | field |}}
    result.{{camel field.name}} = row["{{this.columnName}}"].({{goType field.typeName}})
{{/with}}
{{/each}}
{{/each}}

    return result, nil
}
{{/if}}
{{/if}}
{{#if @last}}{{else}}{{"\n"}}{{/if}}
{{/each}}

func main() {
    // create new router
    router := chi.NewRouter()

    // router middlewares
	router.Use(middleware.RequestID)
    router.Use(middleware.RealIP)
    router.Use(middleware.Logger)
    router.Use(middleware.Recoverer)

    conn, err := sql.Open("postgres", os.Getenv("DATABASE_URL"))
    if err != nil {
    	fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
    	os.Exit(1)
    }
    defer conn.Close()

    client, err := minio.NewV4("localhost:9090", "minio", "miniominio", false)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Unable to connect to s3: %v\n", err)
    	os.Exit(1)
    }

    // routes
    {{#each app.operations as |op|}}
    router.{{title (lower op.hTTPSpec.method)}}("{{op.hTTPSpec.Path}}", func(res http.ResponseWriter, req *http.Request) {
        {{#with (lookupType app.types op.responseTypeFQN) as |returnType| }}
        {{#if op.inputTypeFQN}}
        {{#with (lookupType app.types op.inputTypeFQN) as |inputType| }}
        input := {{camel inputType.name}}{}
        err := json.NewDecoder(req.Body).Decode(&input)
        if err != nil {
            http.Error(
                res,
                MustNewApiError(conn, "Bad Input", err.Error()).MustJSONError(),
                http.StatusBadRequest,
            )
            return
        }
        {{/with}}
        {{/if}}

        {{#each op.plan.databaseOperations as |dbOp|}}
        {{!-- {{this.mustGetSQLArgs}} --}}

        const sqlStr = `{{{dbOp.mustToSQL}}}`
        rows, err := conn.QueryContext(req.Context(), sqlStr{{#each dbOp.inputFieldMappings}}{{#with (lookupField app @key) as |in|}}, input.{{camel in.name}}{{/with}}{{/each}})
        if err != nil {
            http.Error(
                res,
                MustNewApiError(conn, "Internal Server Error", "failed to execute '{{op.name}}' database query: "+err.Error()).MustJSONError(),
                http.StatusInternalServerError,
            )
            return
        }

        result := {{camel returnType.name}}{}
        rowVal := []map[string]interface{}{}
        err = sqlscan.ScanAll(&rowVal, rows)
        if err != nil {
            http.Error(
                res,
                MustNewApiError(conn, "Internal Server Error", "failed to scan results of '{{op.name}}' database query: "+err.Error()).MustJSONError(),
                http.StatusInternalServerError,
            )
            return
        }

        if len(rowVal) == 0 {
            http.Error(
                res,
                MustNewApiError(conn, "Not Found", "'{{op.name}}' database query returned no results").MustJSONError(),
                http.StatusNotFound,
            )
            return
        }
        row := rowVal[0]

{{#each dbOp.dataFieldMappings}}
{{#with (lookupField app @key) as | field |}}
        {{#if (hasSqlScanner field.typeOf)}}
        result.{{camel field.name}} = {{goType field.typeName}}{}
        err = result.{{camel field.name}}.Scan(row["{{this.columnName}}"])
        if err != nil {
            http.Error(
                res,
                MustNewApiError(conn, "Internal Server Error", "'{{op.name}}' failed to scan result field").MustJSONError(),
                http.StatusInternalServerError,
            )
        }
        {{else}}
        result.{{camel field.name}} = row["{{this.columnName}}"].({{goType field.typeName}})
        {{/if}}
{{/with}}
{{/each}}
{{#each dbOp.computationFieldMappings}}
{{#with (lookupField app @key) as | field |}}
        result.{{camel field.name}} = row["{{this.alias}}"].({{goType field.typeName}})
{{/with}}
{{/each}}
{{/each}}
{{#each op.plan.serverOperations}}
{{#with (lookupField app this.resultMappingFQN) as | field |}}
        result.{{camel field.name}} = {{goType field.typeName}}({{this.expression}})
{{/with}}
{{/each}}

{{#each op.plan.filestoreOperations as |fsOp|}}
{{#if (eq fsOp.type "FSREAD")}}
{{#each fsOp.dataFieldMappings as |attr|}}
{{#if (eq attr "list_buckets")}}
        buckets, err := client.ListBuckets()
        if err != nil {
            http.Error(
                res,
                MustNewApiError(conn, "Internal Server Error", "failed to complete list buckets filestore request").MustJSONError(),
                http.StatusInternalServerError,
            )
            return
        }

        bucketNames := []string{}
        for _, bucket := range buckets {
            bucketNames = append(bucketNames, bucket.Name)
        }
{{#with (lookupField app @key) as | field |}}
        result.{{camel field.name}} = bucketNames
{{/with}}
{{/if}}
{{/each}}
{{/if}}
{{/each}}

        encoder := json.NewEncoder(res)
        encoder.SetIndent("", "    ")
        err = encoder.Encode(map[string]any{"result": result})
        if err != nil {
            http.Error(res, err.Error(), http.StatusInternalServerError)
            return
        }
        {{/with}}
    })
    {{/each}}

    log.Println("starting {{app.name}} app on localhost:5050")
	http.ListenAndServe("localhost:5050", router)
}